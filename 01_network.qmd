---
title: "BAHD and SCPL synteny network"
author: "Thomas Naake"
format: 
    html:
        self-contained: true
        code-fold: true
        toc: true
        toc-depth: 3
        toc-expand: true
editor: visual
---

# Prepare the environment

```{r load_libraries}
#| message: FALSE
#| warning: FALSE
library("dplyr")
library("ggplot2")
library("ggpubr")
library("igraph")
library("scales")
```

# Load the files

```{r load_files}
load("BAHD_SCPL_bin_mat_complete_mat_type.RData") 
## contains bin_mat_complete (13535x13535) and mat_type (13535x13535), contains also singletons

load("bin_mat_complete_cut_tandemgenes.RData")
## contains bin_mat_complete_cut (9963x9963) mat_type_cut (9963x9963)
```

# Reconstruct the network for module detection

Continue with the `bin_mat_complete_cut` network and obtain the network components. Most of the components only contain 1 or 2 genomic sites.

Only continue with the 5 largest components that contain syntenic information on 9507 genomic sites.

```{r}
## create a network from the binary matrix (cut)
net <- graph_from_adjacency_matrix(bin_mat_complete_cut, mode="undirected", 
    diag = FALSE, weighted = TRUE)

## only continue with nodes from the big components 1 to 5
names_net <- names(membership(components(net))[
    which(membership(components(net)) %in% 1:5)])
bin_mat_cut <- bin_mat_complete_cut[names_net, names_net]
dim(bin_mat_cut)

## do the same for the matrix that contains the type of link
mat_type_cut <- mat_type_cut[names_net, names_net]
dim(bin_mat_cut)
```

Manually remove some of the edges due to misclassification of MCL/Orthofinder. Those edges are all of type "mcscanx", i.e. they are derived from MCScanX software using the Orthofinder input. The corresonding nodes are all classified as BAHD.

-   n381, "aquco_Aqcoe4G242100.1.p", OG0000212, group_298;
-   n388, "aquco_Aqcoe4G257500.1.p", OG0000161, group_56;
-   n477, "aradu_XP_015954543.1", OG0000161, group_56;
-   n541, "araip_XP_016187645.1", OG0000161, group_56;
-   n2059, "cansa_XP_030478657.1/cansa_XP_030478658.1/cansa_XP_030509927.1/cansa_XP_030511175.1", OG0000161/OG0000161/OG0000161/OG0000161, group_56/group_56/group_56/group_56;
-   n2689, "citcl_XP_006427659.1", OG0000161, group_56;
-   n2915, "citsi_orange1.1t02793.1", OG0000161, group_56;
-   n3799, "glyma_Glyma.15G241300.1.p", OG0000161, group_56;
-   n7411, "phavu_ESW28881", OG0000161, group_56;
-   n8142, "selmo_Smo33608\|PACid_15401917", OG0000161, group_298;
-   n8155, "selmo_Smo407588\|PACid_15419821", OG0000161, group_298;
-   n8177, "selmo_Smo445158\|PACid_15417296", OG0000212, group_56;
-   n8178, "selmo_Smo445159\|PACid_15417297", OG0000161, group_298;
-   n8179, "selmo_Smo445441\|PACid_15419570", OG0000161, group_298;
-   n8180, "selmo_Smo64454\|PACid_15402615", OG0000161, group_298;
-   n8999, "thepa_Tp5g13300", OG0000161, group_56.

The MCL group "group_56" is not a defined BAHD group.

```{r}
## define the nodes according to the "G default node.xlsx" file
n381 <- "aquco_Aqcoe4G242100.1.p"
n388 <- "aquco_Aqcoe4G257500.1.p"
n477 <- "aradu_XP_015954543.1"
n541 <- "araip_XP_016187645.1"
n2059 <- "cansa_XP_030478657.1/cansa_XP_030478658.1/cansa_XP_030509927.1/cansa_XP_030511175.1"
n2689 <- "citcl_XP_006427659.1"
n2915 <- "citsi_orange1.1t02793.1"
n3799 <- "glyma_Glyma.15G241300.1.p"
n7411 <- "phavu_ESW28881"
n8142 <- "selmo_Smo33608|PACid_15401917"
n8155 <- "selmo_Smo407588|PACid_15419821"
n8177 <- "selmo_Smo445158|PACid_15417296"
n8178 <- "selmo_Smo445159|PACid_15417297"
n8179 <- "selmo_Smo445441|PACid_15419570"
n8180 <- "selmo_Smo64454|PACid_15402615"
n8999 <- "thepa_Tp5g13300"

## n2059 (-) n8179
mat_type_cut[n2059, n8179] <- ""
mat_type_cut[n8179, n2059] <- ""
bin_mat_cut[n2059, n8179] <- 0
bin_mat_cut[n8179, n2059] <- 0

## n2689 (-) n8155
mat_type_cut[n2689, n8155] <- ""
mat_type_cut[n8155, n2689] <- ""
bin_mat_cut[n2689, n8155] <- 0
bin_mat_cut[n8155, n2689] <- 0

## n2689 (-) n8178
mat_type_cut[n2689, n8178] <- ""
mat_type_cut[n8178, n2689] <- ""
bin_mat_cut[n2689, n8178] <- 0
bin_mat_cut[n8178, n2689] <- 0

## n2915 (-) n8179
mat_type_cut[n2915, n8179] <- ""
mat_type_cut[n8179, n2915] <- ""
bin_mat_cut[n2915, n8179] <- 0
bin_mat_cut[n8179, n2915] <- 0

## n3799 (-) n8180
mat_type_cut[n3799, n8180] <- ""
mat_type_cut[n8180, n3799] <- ""
bin_mat_cut[n3799, n8180] <- 0
bin_mat_cut[n8180, n3799] <- 0

## n381 (-) n8177
mat_type_cut[n381, n8177] <- ""
mat_type_cut[n8177, n381] <- ""
bin_mat_cut[n381, n8177] <- 0
bin_mat_cut[n8177, n381] <- 0

## n388 (-) n8179
mat_type_cut[n388, n8179] <- ""
mat_type_cut[n8179, n388] <- ""
bin_mat_cut[n388, n8179] <- 0
bin_mat_cut[n8179, n388] <- 0

## n477 (-) n8142
mat_type_cut[n477, n8142] <- ""
mat_type_cut[n8142, n477] <- ""
bin_mat_cut[n477, n8142] <- 0
bin_mat_cut[n8142, n477] <- 0

## n477 (-) n8155
mat_type_cut[n477, n8155] <- ""
mat_type_cut[n8155, n477] <- ""
bin_mat_cut[n477, n8155] <- 0
bin_mat_cut[n8155, n477] <- 0

## n477 (-) n8179
mat_type_cut[n477, n8179] <- ""
mat_type_cut[n8179, n477] <- ""
bin_mat_cut[n477, n8179] <- 0
bin_mat_cut[n8179, n477] <- 0

## n541 (-) n8155
mat_type_cut[n541, n8155] <- ""
mat_type_cut[n8155, n541] <- ""
bin_mat_cut[n541, n8155] <- 0
bin_mat_cut[n8155, n541] <- 0

## n541 (-) n8178
mat_type_cut[n541, n8178] <- ""
mat_type_cut[n8178, n541] <- ""
bin_mat_cut[n541, n8178] <- 0
bin_mat_cut[n8178, n541] <- 0

## n541 (-) n8179
mat_type_cut[n541, n8179] <- ""
mat_type_cut[n8179, n541] <- ""
bin_mat_cut[n541, n8179] <- 0
bin_mat_cut[n8179, n541] <- 0

## n7411 (-) n8142
mat_type_cut[n7411, n8142] <- ""
mat_type_cut[n8142, n7411] <- ""
bin_mat_cut[n7411, n8142] <- 0
bin_mat_cut[n8142, n7411] <- 0

## n7411 (-) n8179
mat_type_cut[n7411, n8179] <- ""
mat_type_cut[n8179, n7411] <- ""
bin_mat_cut[n7411, n8179] <- 0
bin_mat_cut[n8179, n7411] <- 0

## n8142 (-) n8999
mat_type_cut[n8142, n8999] <- ""
mat_type_cut[n8999, n8142] <- ""
bin_mat_cut[n8142, n8999] <- 0
bin_mat_cut[n8999, n8142] <- 0
```

Create now a network from the `bin_mat_cut` adjacency matrix.

```{r}
## create a network from the bin_mat_cut adjacency matrix
net_cut <- graph_from_adjacency_matrix(bin_mat_cut, mode = "undirected", 
    diag = FALSE, weighted = TRUE)
```

How many network components do we have now after manual removal of the false 
edges?

```{r}
length(decompose(net_cut))
```

## Create membership information

After removal, recalculate the communities using the following algorithms:

-   cluster_fast_greedy (fc),
-   cluster_walktrap (wc),
-   cluster_leading_eigen (le),
-   cluster_label_prop (lp),
-   cluster_louvain (ml),
-   cluster_infomap (im)

Create a `membership_community` object to store the results in.

```{r community_detection}
## https://stackoverflow.com/questions/9471906/what-are-the-differences-between-community-detection-algorithms-in-igraph
fc <- cluster_fast_greedy(net_cut, modularity = TRUE, 
    weights = E(net_cut)$weight)
wc <- cluster_walktrap(net_cut, modularity = TRUE, steps = 15, 
    weights = E(net_cut)$weight)
le <- cluster_leading_eigen(net_cut, steps = 15, 
    weights = E(net_cut)$weight)
lp <- cluster_label_prop(net_cut, weights = E(net_cut)$weight)
ml <- cluster_louvain(net_cut, weights = E(net_cut)$weight)
im <- cluster_infomap(net_cut, e.weights = E(net_cut)$weight, 
    nb.trials = 100, modularity = TRUE)

## combine all cluster detection results to a matrix 
if (!all(names(membership(fc)) == names(membership(wc))))
    stop()
if (!all(names(membership(fc)) == names(membership(le))))
    stop()
if (!all(names(membership(fc)) == names(membership(lp))))
    stop()
if (!all(names(membership(fc)) == names(membership(ml))))
    stop()
if (!all(names(membership(fc)) == names(membership(im))))
    stop()
membership_community <- data.frame(
    X = names(membership(fc)), 
    fc = membership(fc), 
    wc = membership(wc), 
    le = membership(le), 
    lp = membership(lp), 
    ml = membership(ml), 
    im = membership(im))
```

Add to the `membership_community` object information on the orthogroup and MCL membership and if the genomic region contains BAHD(s) or SCP/SCPL(s).

```{r add_information_on_orthogroup_mcl, cache = TRUE}
## add empty columns
membership_community$og <- "unknown"
membership_community$mcl <- "unknown"
membership_community$family <- "unknown"

## read the files that contain information on the orthogroup
# bahd <- readxl::read_excel("BAHD & SCPL OGs.xlsx", sheet = "BAHD-ATs") |>
#     as.data.frame()
og <- readr::read_delim("Results_Nov05_Thomas/family_orthogroups_iadhore.txt", 
    col_names = FALSE)
mcl <- readr::read_delim("Results_Nov05_Thomas/family_orthogroups_mcl15.txt", 
    col_names = FALSE)
og_bahd <- c("OG0000346", "OG0000212", "OG0002767", "OG0000119", "OG0001133", 
    "OG0001868", "OG0000161", "OG0000365", "OG0001959", "OG0002199",
    "OG0008747", "OG0002993", "OG0005584", "OG0008842", "OG0005223", 
    "OG0008898")
mcl_bahd <- c("group_414", "group_298", "group_1084", "group_179", "group_56")

# scpl <- readxl::read_excel("BAHD & SCPL OGs.xlsx", sheet = "SCP&SCPL-ATs") |>
#     as.data.frame()
og_scpl <- c("OG0000185", "OG0000121", "OG0001568", "OG0001444", "OG0003193", 
      "OG0003286", "OG0000663", "OG0007821")
mcl_scpl <- c("group_50")

## iterate through the orthogroups and add the information to membership 
## community for BAHDs
for (row_i in seq_len(nrow(membership_community))) {
    
    genes_i <- membership_community[row_i, "X"] |>
        strsplit(split = "/") |>
        unlist()
    
    ## get indices in og and mcl for the genes_i
    inds_og_i <- match(genes_i, og$X1)
    og_i <- og[inds_og_i, "X2"] |>
        unlist() |>
        paste(collapse = "/")
    inds_mcl_i <- match(genes_i, mcl$X1)
    mcl_i <- mcl[inds_mcl_i, "X2"] |>
        unlist() |>
        paste(collapse = "/")
    
    ## write the OG and MCL information to membership_community
    membership_community[row_i, "og"] <- paste(
        membership_community[row_i, "og"], og_i, sep = "/")
    membership_community[row_i, "mcl"] <- paste(
        membership_community[row_i, "mcl"], mcl_i, sep = "/")
    
    ## write the family information to membership_community
    .family <- mcl[inds_mcl_i, "X2"] |>
        unlist() 
    .family[.family %in% mcl_bahd] <- "BAHD"
    .family[.family %in% mcl_scpl] <- "SCPL"
    .family <- paste(.family, collapse = "/")
    membership_community$family[row_i] <- paste(
        membership_community$family[row_i], .family, sep = "/")
}

## replace the NAs (non-matched) groups
membership_community$og <- gsub(pattern = "NA", replacement = "unknown", 
    x = membership_community$og)
membership_community$mcl <- gsub(pattern = "NA", replacement = "unknown", 
    x = membership_community$mcl)
membership_community$family <- gsub(pattern = "NA", replacement = "unknown", 
    x = membership_community$family)

## remove the / in the beginning
membership_community$og <- stringr::str_remove(
    membership_community$og, pattern = "^unknown/")
membership_community$mcl <- stringr::str_remove(
    membership_community$mcl, pattern = "^unknown/")
membership_community$family <- stringr::str_remove(
    membership_community$family, pattern = "^unknown/")

## simplify the family column
membership_community$family <- strsplit(membership_community$family, 
        split = "/") |> 
    lapply(function(entry_i) unique(entry_i)) |>
    lapply(function(entry_i) paste(entry_i, collapse = "/")) |>
    unlist()
write.table(membership_community, 
    file = "membership_community_gene_cluster_added.txt", 
    quote = FALSE, row.names = FALSE, sep = "\t")
```

# Calculate topological parameters

Iterate now through the orthogroups and obtain the networks to calculate network topology parameters.

Define helper functions.

```{r fcts_topological_parameters}
## calculate topological parameters
calculate_topological_parameters <- function(.component) {
        
    ## average local efficiency
    .average_local_efficiency <- average_local_efficiency(.component, 
        weights = E(.component), directed = FALSE, mode = "all")
    
    ## average path length
    .mean_distance <- mean_distance(.component, 
        weights = E(.component), directed = FALSE)
    
    ## betweenness
    .betweenness_normalized <- betweenness(.component, directed = FALSE, 
        weights = E(.component), normalized = TRUE)
    .betweenness_normalized_min <- .betweenness_normalized |>
        min()
    .betweenness_normalized_median <- .betweenness_normalized |>
        median()
    .betweenness_normalized_max <- .betweenness_normalized |>
        max()
    .betweenness_notnormalized <- betweenness(.component, directed = FALSE, 
        weights = E(.component), normalized = FALSE)
    .betweenness_notnormalized_min <- .betweenness_notnormalized |>
        min()
    .betweenness_notnormalized_median <- .betweenness_notnormalized |>
        median()
    .betweenness_notnormalized_max <- .betweenness_notnormalized |>
        max()
    
    ## closeness
    .closeness_normalized <- closeness(.component, mode = "all", 
        weights = E(.component), normalized = TRUE)
    .closeness_normalized_min <- .closeness_normalized |>
        min()
    .closeness_normalized_median <- .closeness_normalized |>
        median()
    .closeness_normalized_max <- .closeness_normalized |>
        max()
    .closeness_notnormalized <- closeness(.component, mode = "all", 
        weights = E(.component), normalized = FALSE)
    .closeness_notnormalized_min <- .closeness_notnormalized |>
        min()
    .closeness_notnormalized_median <- .closeness_notnormalized |>
        median()
    .closeness_notnormalized_max <- .closeness_notnormalized |>
        max()

    ## constraint
    .constraint <- constraint(.component, weights = E(.component))
    .constraint_min <- .constraint |>
        min()
    .constraint_median <- .constraint |>
        median()
    .constraint_max <- .constraint |>
        max()
    
    ## diameter
    .diameter <- diameter(.component, directed = FALSE, weights = E(.component))
    
    ## degree
    .degree_normalized <- degree(.component, normalized = TRUE) 
    .degree_normalized_min <- .degree_normalized |> 
        min()
    .degree_normalized_median <- .degree_normalized |> 
        median()
    .degree_normalized_max <- .degree_normalized |> 
        max()
        
    .degree_notnormalized <- degree(.component, normalized = FALSE) 
    .degree_notnormalized_min <- .degree_notnormalized |> 
        min()
    .degree_notnormalized_median <- .degree_notnormalized |> 
        median()
    .degree_notnormalized_max <- .degree_notnormalized |> 
        max()
        
    ## eccentricity
    .eccentricity <- eccentricity(.component, mode = "all")
    .eccentricity_min <- .eccentricity |>
        min()
    .eccentricity_median <- .eccentricity |>
        median()
    .eccentricity_max <- .eccentricity |>
        max()
    
    ## edge betweenness
    .edge_betweenness <- edge_betweenness(.component, 
        directed = FALSE, weights = E(.component))
    .edge_betweenness_min <- .edge_betweenness |>
        min()
    .edge_betweenness_median <- .edge_betweenness |>
        median()
    .edge_betweenness_max <- .edge_betweenness |>
        max()

    ## eigencentrality
    .eigen_centrality <- eigen_centrality(.component, 
        weights = E(.component), scale = FALSE)
    .eigen_centrality_min <- .eigen_centrality$vector |> 
        min()
    .eigen_centrality_median <- .eigen_centrality$vector |> 
        median()
    .eigen_centrality_max <- .eigen_centrality$vector |> 
        max()
    .eigen_centrality_value <- .eigen_centrality$value
     
    ## global efficiency
    .global_efficiency <- global_efficiency(.component, 
        weights = E(.component), directed = TRUE)
    
    ## harmonic centrality
    .harmonic_centrality <- harmonic_centrality(.component, mode = "all", 
        weights = E(.component)) 
    .harmonic_centrality_min <- .harmonic_centrality |>
        min()
    .harmonic_centrality_median <- .harmonic_centrality |>
        median()
    .harmonic_centrality_max <- .harmonic_centrality |>
        max()
    
    ## neighborhood size
    .neighborhood_size <- neighborhood_size(.component, order = 1, mode = "all")
    .neighborhood_size_min <- .neighborhood_size |>
        min()
    .neighborhood_size_median <- .neighborhood_size |>
        median()
    .neighborhood_size_max <- .neighborhood_size |>
        max()
    
    ## number of nodes
    .number_nodes <- length(.component)
    
    ## radius
    .radius <- radius(.component, mode = "all")
    
    ## strength
    .strength <- strength(.component, mode = "all", loops = FALSE, 
        weights = E(.component))
    .strength_min <- .strength |>
        min()
    .strength_median <- .strength |>
        median()
    .strength_max <- .strength |>
        max()
        
    ## shortest path/distance
    .distances <- distances(.component, mode = "all", 
        weights = E(.component))
    .distances_min <- .distances |>
        min()
    .distances_median <- .distances |>
        median()
    .distances_max <- .distances |>
        max()
        
    ## create data.frame to store resutls and to return
    data.frame(
        ## average local efficiency
        average_local_efficiency = .average_local_efficiency,
    
        ## average path length
        mean_distance = .mean_distance,
        
        ## betweenness
        betweenness_normalized_min = .betweenness_normalized_min,
        betweenness_normalized_median = .betweenness_normalized_median,
        betweenness_normalized_max = .betweenness_normalized_max,
        betweenness_notnormalized_min = .betweenness_notnormalized_min,
        betweenness_notnormalized_median = .betweenness_notnormalized_median,
        betweenness_notnormalized_max = .betweenness_notnormalized_max,
        
        ## closeness
        closeness_normalized_min = .closeness_normalized_min,
        closeness_normalized_median = .closeness_normalized_median,
        closeness_normalized_max = .closeness_normalized_max,
        closeness_notnormalized_min = .closeness_notnormalized_min,
        closeness_notnormalized_median = .closeness_notnormalized_median,
        closeness_notnormalized_max = .closeness_notnormalized_max,
    
        ## constraint
        constraint_min = .constraint_min,
        constraint_median = .constraint_median,
        constraint_max = .constraint_max,
        
        ## diameter
        diameter = .diameter,
            
        ## degree
        degree_normalized_min = .degree_normalized_min,
        degree_normalized_median = .degree_normalized_median,
        degree_normalized_max = .degree_normalized_max,
        degree_notnormalized_min = .degree_notnormalized_min,
        degree_notnormalized_median = .degree_notnormalized_median,
        degree_notnormalized_max = .degree_notnormalized_max,
            
        ## eccentricity
        eccentricity_min = .eccentricity_min,
        eccentricity_median = .eccentricity_median,
        eccentricity_max = .eccentricity_max,
        
        ## edge betweenness
        edge_betweenness_min = .edge_betweenness_min,
        edge_betweenness_median = .edge_betweenness_median,
        edge_betweenness_max = .edge_betweenness_max,
    
        ## eigencentrality
        eigen_centrality_min = .eigen_centrality_min,
        eigen_centrality_median = .eigen_centrality_median,
        eigen_centrality_max = .eigen_centrality_max,
        eigen_centrality_value = .eigen_centrality_value,
        
        ## global efficiency
        global_efficiency = .global_efficiency,
        
        ## harmonic centrality 
        harmonic_centrality_min = .harmonic_centrality_min,
        harmonic_centrality_median = .harmonic_centrality_median,
        harmonic_centrality_max = .harmonic_centrality_max,
        
        ## neighborhood size
        neighborhood_size_min = .neighborhood_size_min,
        neighborhood_size_median = .neighborhood_size_median,
        neighborhood_size_max = .neighborhood_size_max,
        
        ## number of nodes
        number_nodes = .number_nodes, 
        
        ## radius
        radius = .radius,
        
        ## strength
        strength_min = .strength_min,
        strength_median = .strength_median,
        strength_max = .strength_max,
            
        ## shortest path/distance
        distances_min = .distances_min,
        distances_median = .distances_median,
        distances_max = .distances_max
    )
}

## wrapper function that iterates through orthogroups and calculates 
## topology parameters of components
#' @param og character containing names of orthogroups
get_topology_for_components <- function(og = og_bahd) {
    
    ## create list to store information on orthogroup components
    component_size <- list()
    for (i in seq_len(length(og))) {
        genes <- membership_community[membership_community$og == og[i], "X"]
        g <- graph_from_adjacency_matrix(bin_mat_cut[genes, genes], 
            mode = "undirected", diag = FALSE, weighted = TRUE)
        .components <- decompose(g, min.vertices = 11)
    
        ## calculate topological parameters, add information on the component, and
        ## combine into one data.frame
        topological_parameters_i <- lapply(seq_along(.components), function(j) {
            df <- calculate_topological_parameters(
                .component = .components[[j]])
            cbind(df, component = paste(og[i], j, sep = "_"))
        })
        topological_parameters_i <- do.call("rbind", topological_parameters_i) 
        component_size[[og[i]]] <- components(g)$csize
   
        if (i == 1) {
            topological_parameters <- topological_parameters_i
        } else {
            topological_parameters <- rbind(topological_parameters, 
                topological_parameters_i)    
        }
    }
    
    list(
        topological_parameters = topological_parameters, 
        component_size = component_size)
}
```

Apply the function on orthogroups of BAHD and SCPL genes

```{r calculate_topology_parameters}
## apply the function on orthogroups of BAHD and SCPL genes
topology_bahd <- get_topology_for_components(og = og_bahd)
topology_scpl <- get_topology_for_components(og = og_scpl)

## write the network_topology_components to the community_member file
membership_community$topology_component <- "undefined"
for (i in seq_len(length(og_bahd))) {
    genes <- membership_community[membership_community$og == og_bahd[i], "X"]
    g <- graph_from_adjacency_matrix(bin_mat_cut[genes, genes], 
        mode = "undirected", diag = FALSE, weighted = TRUE)
    .components <- decompose(g, min.vertices = 3)
        for (j in seq_along(.components)) {
            .components_j <- .components[[j]]
            genes_j <- V(.components_j) |>
                names()
            inds <- which(membership_community$X %in% genes_j)
            membership_community$topology_component[inds] <- paste(
                membership_community$topology_component[inds], 
                paste("BAHD", og_bahd[i], j, sep = "_"), sep = "/"
            )
        }
}
for (i in seq_len(length(og_scpl))) {
    genes <- membership_community[membership_community$og == og_scpl[i], "X"]
    g <- graph_from_adjacency_matrix(bin_mat_cut[genes, genes], 
        mode = "undirected", diag = FALSE, weighted = TRUE)
    .components <- decompose(g, min.vertices = 3)
        for (j in seq_along(.components)) {
            .components_j <- .components[[j]]
            genes_j <- V(.components_j) |>
                names()
            inds <- which(membership_community$X %in% genes_j)
            membership_community$topology_component[inds] <- paste(
                membership_community$topology_component[inds], 
                paste("SCPL", og_scpl[i], j, sep = "_"), sep = "/"
            )
        }
}
membership_community$topology_component <- stringr::str_remove(
    membership_community$topology_component, pattern = "undefined/")

## add information on BAHD and SCPL genes
topology_bahd[[1]]$family <- "BAHD"
topology_scpl[[1]]$family <- "SCPL"
```

## Plotting

Do the actual plotting.

```{r fcts_plot_topology_parameters}
plot_topology_parameter <- function(.topology_bahd = topology_bahd, 
    .topology_scpl = topology_scpl, plot = "degree", log10_x = FALSE, 
    log10_y = FALSE, offset_x = 0, offset_y = 0, .model = TRUE, method = "lm",
    .digits_x = 0, .digits_y = 2, 
    custom_ticks_x = c(50, 100, 250, 500, 750, 1250), custom_ticks_y = c(0.1, 1)) {
    
    ## row bind topology_bahd and topology_scpl
    bahd_data <- .topology_bahd[[1]]
    scpl_data <- .topology_scpl[[1]]
    topology <- rbind(bahd_data, scpl_data)
    
    ## select the columns
    topology_l <- topology |> 
        dplyr::select(any_of(plot), number_nodes, family, component)
    
    ## transform (log) 
    if (log10_x)
        topology_l[["number_nodes"]] <- log10(topology_l[["number_nodes"]] + offset_x)
    if (log10_y)
        topology_l[[plot]] <- log10(topology_l[[plot]] + offset_y)
    
    ## do the actual plotting
    gg <- topology_l |>
        ggplot(aes(x = number_nodes, y = .data[[plot]], color = family)) +
            geom_point() +
            suppressWarnings(
                ggplot2::geom_point(ggplot2::aes(text = component)))
    if (.model)
        gg <- gg +
            geom_smooth(method = method, se = FALSE, alpha = 0.02)
    
    if (log10_x) {
        gg <- gg +
            scale_x_continuous(
            breaks = log10(custom_ticks_x + offset_x),
            labels = function(x) format_format() 
                (round(10^x - offset_x, digits = .digits_x)),
            limits = c(log10(min(custom_ticks_x + offset_x)),
                log10(max(custom_ticks_x + offset_x))))
    } else {
        gg <- gg +
            scale_x_continuous(breaks = custom_ticks_x,
                limits = c(min(custom_ticks_x), max(custom_ticks_x)))
    }
        
    if (log10_y) {
        gg <- gg + 
            scale_y_continuous(
                breaks = log10(custom_ticks_y + offset_y),
                labels = function(x) format_format() 
                    (round(10^x - offset_y, digits = .digits_y)),
                limits = c(log10(min(custom_ticks_y + offset_y)), 
                   log10(max(custom_ticks_y))))
    } else {
        gg <- gg + 
            scale_y_continuous(breaks = custom_ticks_y,
                limits = c(min(custom_ticks_y), max(custom_ticks_y)))
    }
    
    #gg <- gg + 
     #   xlim(min(custom_ticks_x), max(custom_ticks_x)) +
     #   ylim(min(custom_ticks_y), max(custom_ticks_y))
        

    gg_scatter <- gg +
        xlab("number of nodes per component") + ylab(plot) +
        ggtitle(plot) +
        labs(color = "gene family") +
        theme_classic() 
            
    gg_scatter_plotly <- plotly::ggplotly(gg_scatter, tooltip = c("text")) |>
        plotly::partial_bundle()
    
    ## information on the model
    if (.model) {
        
        print(paste("The function will perform", nrow(scpl_data), "and",
            nrow(bahd_data), "bootstrap repetitions for SCPL and BAHD.", 
            sep = " "))
        
        ## bahd
        bahd_coefs <- lapply(seq_len(nrow(bahd_data)), function(i) {
            new_rows <- sample(x = seq_len(nrow(bahd_data)), 
                size = nrow(bahd_data), replace = TRUE)
            new_data <- bahd_data[new_rows, ]
            .model <- lm(new_data[[plot]] ~ number_nodes, data = new_data)
            
            list(
                .model$coefficients[["(Intercept)"]], 
                .model$coefficients[["number_nodes"]]) 
        })
        bahd_coefs_intercept <- lapply(bahd_coefs, "[", 1) |>
            unlist()
        bahd_coefs_nn <- lapply(bahd_coefs, "[", 2) |> 
            unlist()
        
        ## scpl
        scpl_coefs <- lapply(seq_len(nrow(scpl_data)), function(i) {
            new_rows <- sample(x = seq_len(nrow(scpl_data)), 
                size = nrow(scpl_data), replace = TRUE)
            new_data <- scpl_data[new_rows, ]
            .model <- lm(new_data[[plot]] ~ number_nodes, data = new_data)
            list(
                .model$coefficients[["(Intercept)"]], 
                .model$coefficients[["number_nodes"]]) 
        })
        scpl_coefs_intercept <- lapply(scpl_coefs, "[", 1) |>
            unlist()
        scpl_coefs_nn <- lapply(scpl_coefs, "[", 2) |> 
            unlist()
        df <- rbind(
            data.frame(value = bahd_coefs_intercept, family = "BAHD", 
                coefficient = "intercept"),
            data.frame(value = bahd_coefs_nn, family = "BAHD", 
                coefficient = "number_nodes"),
            data.frame(value = scpl_coefs_intercept, family = "SCPL", 
                coefficient = "intercept"),
            data.frame(value = scpl_coefs_nn, family = "SCPL", 
                coefficient = "number_nodes"))
       
        
        gg_boxplot <- ggboxplot(df, x = "family", y = "value", title = plot, 
                facet.by = "coefficient", scales = "free_y") +
            stat_compare_means(comparisons = list(c("BAHD", "SCPL")), 
                method = "t.test")
        
        ttest_intercept <- t.test(bahd_coefs_intercept, scpl_coefs_intercept)
        ttest_nn <- t.test(bahd_coefs_nn, scpl_coefs_nn)
        
        ## get the empirical model coefficients
        ## bahd
        bahd_coef_empirical <- lapply(1, function(i) {
            .model <- lm(bahd_data[[plot]] ~ number_nodes, data = bahd_data)
            list(
                .model$coefficients[["(Intercept)"]], 
                .model$coefficients[["number_nodes"]]) 
        })
        bahd_coef_intercept <- lapply(bahd_coef_empirical, "[", 1) |>
            unlist()
        bahd_coef_nn <- lapply(bahd_coef_empirical, "[", 2) |> 
            unlist()
        
        ## scpl
        scpl_coefs_empirical <- lapply(1, function(i) {
            .model <- lm(scpl_data[[plot]] ~ number_nodes, data = scpl_data)
            list(
                .model$coefficients[["(Intercept)"]], 
                .model$coefficients[["number_nodes"]]) 
        })
        scpl_coef_intercept <- lapply(scpl_coefs_empirical, "[", 1) |>
            unlist()
        scpl_coef_nn <- lapply(scpl_coefs_empirical, "[", 2) |> 
            unlist()

        df_ttest <- data.frame(
            BAHD_intercept_empirical = bahd_coef_intercept,
            BAHD_nn_empirical = bahd_coef_nn,
            SCPL_intercept_empirical = scpl_coef_intercept,
            SCPL_nn_empirical = scpl_coef_nn,
            intercept_t = ttest_intercept$statistic, 
            intercept_df = ttest_intercept$parameter, 
            intercept_p = ttest_intercept$p.value,
            nn_t = ttest_nn$statistic, nn_df = ttest_nn$parameter, 
            nn_p = ttest_nn$p.value)
        rownames(df_ttest) <- plot
        
        list(scatter = gg_scatter, scatter_plotly = gg_scatter_plotly, 
            bootstrap = gg_boxplot, ttest = df_ttest)
    } else {
        list(scatter = gg_scatter, scatter_plotly = gg_scatter_plotly)    
    }
}
```

### average_local_efficiency

```{r average_local_efficiency, warning=TRUE, message=FALSE}
## average_local_efficiency
tp <- plot_topology_parameter(plot = "average_local_efficiency", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 6,
    custom_ticks_y = c(0.001, 0.005, 0.01, 0.015, 0.05))
tp$scatter
tp$scatter_plotly
 tp$bootstrap
ttest_average_local_efficiency <- tp$ttest
```

### mean_distance

```{r mean_distance, warning=TRUE, message=FALSE}
## mean_distance
tp <- plot_topology_parameter(plot = "mean_distance", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(250, 500, 1500, 5000, 10000))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_mean_distance <- tp$ttest
```

### betweenness_normalized

```{r betweenness_normalized, warning=TRUE, message=FALSE}
## betweenness_normalized
tp <- plot_topology_parameter(plot = "betweenness_normalized_min", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(0.005, 0.01, 0.015, 0.02))
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# tp$ttest
tp <- plot_topology_parameter(plot = "betweenness_normalized_median", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(1e-12, 1e-9, 1e-6, 1e-3, 1e-1), .digits_y = 12)
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# tp$ttest
tp <- plot_topology_parameter(plot = "betweenness_normalized_max", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1.0))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_betweenness_normalized_max <- tp$ttest
tp <- plot_topology_parameter(
    plot = "betweenness_notnormalized_min", log10_x = TRUE, log10_y = TRUE,
    offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(0.005, 0.01, 0.015, 0.02))
tp$scatter
tp$scatter_plotly
##tp$bootstrap
##tp$ttest
tp <- plot_topology_parameter(plot = "betweenness_notnormalized_median", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 1, .model = FALSE,
    custom_ticks_y = c(0.0, 1, 5, 10, 20))
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# tp$ttest
tp <- plot_topology_parameter(
    plot = "betweenness_notnormalized_max", log10_x = TRUE, log10_y = TRUE,
    offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(2000, 10000, 30000, 100000, 400000))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_betweenness_notnormalized_max <- tp$ttest
```

### closeness

```{r closeness, warning=TRUE, message=FALSE}
## closeness
tp <- plot_topology_parameter(plot = "closeness_normalized_min", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 10,
    custom_ticks_y = c(2e-05, 3e-05, 4e-05, 5e-05, 7e-05, 1e-04, 2e-04, 4e-04, 3e-04, 5e-04, 8e-04))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_closeness_normalized_min <- tp$ttest
tp <- plot_topology_parameter(plot = "closeness_normalized_median", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, 
    .digits_y = 6,
    custom_ticks_y = c(0.0001, 0.001, 0.01))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_closeness_normalized_median <- tp$ttest
tp <- plot_topology_parameter(plot = "closeness_normalized_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 5,
    custom_ticks_y = c(0.0001, 0.00025, 0.001, 0.0025, 0.005, 0.0075))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_closeness_normalized_max <- tp$ttest
tp <- plot_topology_parameter(plot = "closeness_notnormalized_min", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, 
    .digits_y = 10,
    custom_ticks_y = c(1e-08, 1e-07, 1e-06, 1e-05))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_closeness_notnormalized_min <- tp$ttest
tp <- plot_topology_parameter(plot = "closeness_notnormalized_median", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, 
    .model = TRUE, .digits_y = 10,
    custom_ticks_y = c(1e-07, 1e-06, 1e-05, 1e-04))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_closeness_notnormalized_median <- tp$ttest
tp <- plot_topology_parameter(plot = "closeness_notnormalized_max", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, 
    .digits_y = 10,
    custom_ticks_y = c(1e-07, 1e-06, 1e-05, 1e-04, 5e-04))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_closeness_notnormalized_max <- tp$ttest
```

### constraint

```{r constraint, warning=TRUE, message=FALSE}
## constraint
tp <- plot_topology_parameter(plot = "constraint_min", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(0.01, 0.02, 0.03, 0.06, 0.1, 0.2))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_constraint_min <- tp$ttest
tp <- plot_topology_parameter(plot = "constraint_median", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(0.04, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_constraint_median <- tp$ttest
tp <- plot_topology_parameter(plot = "constraint_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(0.5, 0.75, 1, 1.25, 1.5))
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# tp$ttest
```

### diameter

```{r diameter, warning=TRUE, message=FALSE}
## diameter
tp <- plot_topology_parameter(plot = "diameter", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(1000, 2000, 5000, 10000, 25000, 50000, 100000))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_diameter <- tp$ttest
```

### degree

```{r degree, warning=TRUE, message=FALSE}
## degree
tp <- plot_topology_parameter(plot = "degree_normalized_min", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 10,
    custom_ticks_y = c(0.0003, 0.001, 0.003, 0.01, 0.03))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_degree_normalized_min <- tp$ttest
tp <- plot_topology_parameter(plot = "degree_normalized_median", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 10,
    custom_ticks_y = c(0.01, 0.1, 0.3, 0.5, 0.8))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_degree_normalized_median <- tp$ttest
tp <- plot_topology_parameter(plot = "degree_normalized_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 10,
    custom_ticks_y = c(0.1, 0.2, 0.3, 0.5, 0.8, 1))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_degree_normalized_max <- tp$ttest
tp <- plot_topology_parameter(plot = "degree_notnormalized_min", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(1, 1.5, 2))
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# tp$ttest
tp <- plot_topology_parameter(plot = "degree_notnormalized_median", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(3, 5, 10, 20, 30, 50, 70))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_degree_notnormalized_median <- tp$ttest
tp <- plot_topology_parameter(plot = "degree_notnormalized_max", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(10, 30, 50, 100, 200))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_degree_notnormalized_max <- tp$ttest
```

### eccentricity

```{r eccentricity, warning=TRUE, message=FALSE}
## eccentricity
tp <- plot_topology_parameter(plot = "eccentricity_min", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(2, 2.5, 3, 4, 5, 7.5))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_eccentricity_min <- tp$ttest
tp <- plot_topology_parameter(plot = "eccentricity_median", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(2, 4, 6, 8, 10, 12))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_eccentricity_median <- tp$ttest
tp <- plot_topology_parameter(plot = "eccentricity_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(4, 5, 6, 8, 10, 12.5, 15))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_eccentricity_max <- tp$ttest
```

### edge_betweenness

```{r edge_betweenness, warning=TRUE, message=FALSE}
## edge_betweenness
tp <- plot_topology_parameter(plot = "edge_betweenness_min", log10_x = FALSE, 
    log10_y = FALSE, offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(0.0, 0.05, 0.1))
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# ttest_edge_betweenness_min <- tp$ttest
tp <- plot_topology_parameter(plot = "edge_betweenness_median", log10_x = FALSE,
    log10_y = FALSE, offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(0, 1, 2))
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# ttest_edge_betweenness_median <- tp$ttest
tp <- plot_topology_parameter(plot = "edge_betweenness_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_edge_betweenness_max <- tp$ttest
```

### eigen_centrality

```{r eigen_centrality, warning=TRUE, message=FALSE}
## eigen_centrality
tp <- plot_topology_parameter(plot = "eigen_centrality_min", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 15,
    custom_ticks_y = c(1e-14, 1e-12, 1e-10, 1e-8, 1e-6, 1e-04, 5e-04))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_eigen_centrality_min <- tp$ttest
tp <- plot_topology_parameter(plot = "eigen_centrality_median", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(1e-04, 3e-04, 1e-03, 3e-03, 0.01, 0.03, 0.1, 0.3), .digits_y = 10)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_eigen_centrality_median <- tp$ttest
tp <- plot_topology_parameter(plot = "eigen_centrality_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(0.1, 0.15, 0.2, 0.25, 0.35), .digits_y = 10)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_eigen_centrality_max <- tp$ttest
tp <- plot_topology_parameter(plot = "eigen_centrality_value", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(1e3, 1e4, 1e5, 1e6, 1e7))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_eigen_centrality_value <- tp$ttest
```

### global_efficiency

```{r global_efficiency, warning=TRUE, message=FALSE}
## global_efficiency
tp <- plot_topology_parameter(plot = "global_efficiency", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(0.0001, 0.001, 0.004, 0.01, 0.04), .digits_y = 3)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_global_efficiency <- tp$ttest
```

### harmonic_centrality

```{r harmonic_centrality, warning=TRUE, message=FALSE}
## harmonic_centrality
tp <- plot_topology_parameter(plot = "harmonic_centrality_min", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE, .digits_y = 10,
    custom_ticks_y = c(0.01, 0.02, 0.03, 0.04, 0.06, 0.08))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_harmonic_centrality_min <- tp$ttest
tp <- plot_topology_parameter(plot = "harmonic_centrality_median", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(0.2, 0.4, 0.6, 1), .digits_y = 10,)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_harmonic_centrality_median <- tp$ttest
tp <- plot_topology_parameter(plot = "harmonic_centrality_max", log10_x = TRUE,
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(2, 3, 4, 5, 7), .digits_y = 10,)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_harmonic_centrality_max <- tp$ttest
```

### neighborhood_size

```{r neighborhood_size, warning=TRUE, message=FALSE}
## neighborhood_size
tp <- plot_topology_parameter(plot = "neighborhood_size_min", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(2, 2.5, 3))
tp$scatter
tp$scatter_plotly
##tp$bootstrap
##ttest_neighborhood_size_min <- tp$ttest
tp <- plot_topology_parameter(plot = "neighborhood_size_median", 
    log10_x = TRUE, log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(5, 7, 10, 15, 30, 50, 70))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_neighborhood_size_median <- tp$ttest
tp <- plot_topology_parameter(plot = "neighborhood_size_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(20, 30, 50, 100, 150, 200, 250), .digits_y = 10) 
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_neighborhood_size_max <- tp$ttest
```

### radius

```{r radius, warning=TRUE, message=FALSE}
## radius
tp <- plot_topology_parameter(plot = "radius", log10_x = TRUE, log10_y = TRUE,
    offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(2, 2.5, 3, 4, 5, 6, 7))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_radius <- tp$ttest
```

### strength

```{r strength, warning=TRUE, message=FALSE}
## strength
tp <- plot_topology_parameter(plot = "strength_min", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 1200))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_strength_min <- tp$ttest
tp <- plot_topology_parameter(plot = "strength_median", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(1e02, 1e03, 1e04, 1e05, 1e06), .digits_y = 10)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_strength_median <- tp$ttest
tp <- plot_topology_parameter(plot = "strength_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(3000, 10000, 30000, 100000, 300000, 1000000, 3000000))
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_strength_max <- tp$ttest
```

### distances

```{r distances, warning=TRUE, message=FALSE}
tp <- plot_topology_parameter(plot = "distances_min", log10_x = FALSE, log10_y = F,
    offset_x = 0, offset_y = 0, .model = FALSE,
    custom_ticks_y = c(-0.05, -0.025, 0, 0.025, 0.05))
tp$scatter
tp$scatter_plotly
# tp$bootstrap
# tp$ttest
tp <- plot_topology_parameter(plot = "distances_median", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(80, 100, 300, 1000, 3000, 6000), .digits_y = 10)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_distances_median <- tp$ttest
tp <- plot_topology_parameter(plot = "distances_max", log10_x = TRUE, 
    log10_y = TRUE, offset_x = 0, offset_y = 0, .model = TRUE,
    custom_ticks_y = c(1000, 3000, 10000, 30000, 100000), .digits_y = 10)
tp$scatter
tp$scatter_plotly
tp$bootstrap
ttest_distances_max <- tp$ttest
```

### Multiple testing correction via FDR

Combine first the test results. Then adjust via FDR using the Benjamini-Hochberg method the raw p-values using the number of models.

```{r multiple_testing_correction}
ttest_df <- rbind(
    ttest_average_local_efficiency,
    ttest_mean_distance,
    ttest_betweenness_normalized_max,
    ttest_betweenness_notnormalized_max,
    ttest_closeness_normalized_min,
    ttest_closeness_normalized_median,
    ttest_closeness_normalized_max,
    ttest_closeness_notnormalized_min,
    ttest_closeness_notnormalized_median,
    ttest_closeness_notnormalized_max,
    ttest_constraint_min,
    ttest_constraint_median,
    ttest_diameter,
    ttest_degree_normalized_min,
    ttest_degree_normalized_median,
    ttest_degree_normalized_max,
    ttest_degree_notnormalized_median,
    ttest_degree_notnormalized_max,
    ttest_eccentricity_min,
    ttest_eccentricity_median,
    ttest_eccentricity_max,
    ##ttest_edge_betweenness_min,
    ##ttest_edge_betweenness_median,
    ttest_edge_betweenness_max,
    ttest_eigen_centrality_min,
    ttest_eigen_centrality_median,
    ttest_eigen_centrality_max,
    ttest_eigen_centrality_value,
    ttest_global_efficiency,
    ttest_harmonic_centrality_min,
    ttest_harmonic_centrality_median,
    ttest_harmonic_centrality_max,
    ttest_neighborhood_size_median,
    ttest_neighborhood_size_max,
    ttest_neighborhood_size_median,
    ttest_neighborhood_size_max,
    ttest_radius,
    ttest_strength_min,
    ttest_strength_median,
    ttest_strength_max,
    ttest_distances_median,
    ttest_distances_max)
ttest_df$intercept_p_adj <- p.adjust(ttest_df$intercept_p, method = "BH")
ttest_df$nn_p_adj <- p.adjust(ttest_df$nn_p, method = "BH")
```

Return the table with all the information (t-values, df, raw p-values, 
adjusted p-values) for the intercept and the `number_nodes` parameter 
(gradient).

```{r}
## return the final table
rmarkdown::paged_table(ttest_df)
write.table(ttest_df, file = "linear_model_parameter_ttest_values.txt", 
    sep = "\t", dec = ".")
```

What are the parameters that show differences in the intercept parameter?

```{r}
rmarkdown::paged_table(ttest_df[ttest_df$intercept_p_adj <= 0.05, ])
```

What are the parameters that show differences in the `number_nodes` parameter?

```{r}
rmarkdown::paged_table(ttest_df[ttest_df$nn_p_adj <= 0.05, ])
```

What are the parameters that both show differences in the intercept and 
`number_nodes` parameter?

```{r}
rmarkdown::paged_table(
    ttest_df[ttest_df$intercept_p_adj <= 0.05 & ttest_df$nn_p_adj <= 0.05, ])
```

# Cliques

Find all complete subgraphs in the input graph.

Define functions.

```{r fcts_cliques}
#' @name find_largest_non_overlapping_cliques
#' 
#' @title Find largest non-overlapping cliques
#' 
#' @description The function will find largest cliques that are not 
#' overlapping. The function will start with the largest possible clique
#' and remove the used nodes. It will then find the second largest possible 
#' clique and remove again the nodes in that clique. This procedure is repeated
#' until all nodes in the original network \code{g}. This might mean that
#' that some of the nodes in \code{g} will be a assigned to cliques of size 1.
#' 
#' The function will select randomly a clique if there are several largest
#' possible cliques. This will mean the function might yield different 
#' results when applying the function on the same network.
#' 
#' @param g igraph network
find_largest_non_overlapping_cliques <- function(g) {
    
    non_overlapping_cliques <- list()
    while (vcount(g) > 0) {
        ## find maximal clique in the current graph and select the first one 
        clique <- largest_cliques(g)
        ## select randomly the largest clique
        clique <- clique[[sample(x = seq_len(length(clique)), size = 1)]] |>
            names()
    
        if (length(clique) > 0) {
            ## add the clique to the result
            non_overlapping_cliques <- c(non_overlapping_cliques, list(clique))
      
            ## Remove the nodes of the clique from the graph
            g <- delete_vertices(g, clique)
        } else {
            ## no more cliques can be found
            break
        }
    }

    ## return the object  
    non_overlapping_cliques
}

#' @name greedy_clique
#' 
#' @title Perform a greedy clique determination over all network components
#' 
#' @description 
#' The function applies the function \code{find_largest_non_overlapping_cliques} 
#' on each network component of \code{g}. The function
#' \code{find_largest_non_overlapping_cliques} is run \code{nrep}-times
#' on the algorithms to select randomly the largest cliques in each step and
#' to continue selecting the 2nd largest clique and so on.
#' 
#' The optimal result is then determined by the length of found cliques
#' (preferred are a smaller number of cliques) and a high median membership
#' of genomic regions.
#' 
greedy_clique <- function(g, n_rep = 100) {
    .components <- igraph::decompose(graph = g)
    
    cliques_l <- list()
    ## create a nested list, the outer list for the components, the middle 
    ## list contains the repetitions, the inner list contains the clique 
    ## information
    for (i in seq_along(.components)) {
        cliques_l[[i]] <- lapply(seq_len(n_rep), 
            function(j) find_largest_non_overlapping_cliques(
                g = .components[[i]]))
    }
    
    ## obtain the number of items in each clique clique_i
    len_clique <- lapply(cliques_l, function(cliques) {
        lapply(cliques, function(clique_i) {unlist(lapply(clique_i, length))})
    })
    
    ## get the repetitions with the lowest number of cliques, the object will
    ## be a list of length(number of components) containing for each repetition
    ## the number of cliques
    len_cliques <- lapply(len_clique, function(len_clique_i) {
        len_clique_i_l <- lapply(len_clique_i, length)
        unlist(len_clique_i_l)})
    inds_len_cliques <- lapply(len_cliques, function(len_i) len_i == min(len_i))
    
    ## get from these lowest number cliques, the clique with the highest median
    clique_median <- lapply(len_clique, function(len_clique_i) {
        
        unlist(lapply(len_clique_i, median))
        ##len_clique_i <- len_clique_i[inds_len_cliques[[i]]]
    })
    inds_median_max_cliques <- lapply(seq_along(clique_median), function(i) {
        max_median <- max(clique_median[[i]][inds_len_cliques[[i]]])
        clique_median[[i]] == max_median
    })
    
    ## combine the lowest number and median information
    inds_combined <- lapply(seq_along(inds_len_cliques), function(i) {
        which(inds_len_cliques[[i]] & inds_median_max_cliques[[i]])[1]
    })
    
    ## obtain the final clique for each component
    lapply(seq_along(cliques_l), function(i) {
        cliques_l[[i]][[inds_combined[[i]]]]
    })
}
```

Run the greedy clique determination (each with 100 repetitions) on two different inputs

-   using the network derived from MCL groups and Orthofinder orthogroups,
-   using the network derived from Orthofinder orthogroups,

## MCL group and Orthofinder orthogroup input

First step is to transform the weighted matrix into a binary matrix. All weights `>= 0.25` will have a binary weight of 1.

```{r}
bin_mat_clique_og_mcl <- bin_mat_cut
bin_mat_clique_og_mcl[bin_mat_clique_og_mcl >= .25] <- 1
```

Apply now the function on the graph (for MCL group and Orthofinder orthogroup input).

```{r clique_og_mcl, cache = TRUE}
g <- igraph::graph_from_adjacency_matrix(bin_mat_clique_og_mcl, 
    mode = "undirected", weighted = NULL, diag = FALSE)
cliques_greedy <- greedy_clique(g, n_rep = 100)

## write the result to membership_community
membership_community$component_og_mcl <- "unknown"
membership_community$clique_og_mcl <- "unknown"

for (component_i in seq_along(cliques_greedy)) {
    
    component_name <- paste("component", component_i, sep = "_")
    for (clique_i in seq_along(cliques_greedy[[component_i]])) {
        clique_name <- paste(component_name, "clique", clique_i, sep = "_")
        
        ## find the rows of the members of the clique and write to
        ## membership_community
        ind_rows <- which(
            membership_community$X %in% 
                cliques_greedy[[component_i]][[clique_i]])
        membership_community[ind_rows, "component_og_mcl"] <- component_name
        membership_community[ind_rows, "clique_og_mcl"] <- clique_name
    }
}
```

## Only Orthofinder orthogroup input

First step is to transform the weighted matrix into a binary matrix. Set all edges that do not contain information from Orthofinder to 0, in other words set the edges that are only derived from the MCL input to 0.

Then set all weights `>= 0.25` to a binary weight of 1.

```{r}
bin_mat_clique_og <- bin_mat_cut
## define the types that only contain information from MCL
## tmp <- names(table(bin_mat_type))
## tmp[!grepl(tmp, pattern = "iadhore$|iadhore/|mcscanx$|mcscanx/")]
bin_mat_clique_og[
    mat_type_cut %in% 
        c("iadhore_mcl", "iadhore_mcl/mcscanx_mcl", "mcscanx_mcl")] <- 0
bin_mat_clique_og[bin_mat_clique_og >= .25] <- 1
```

Apply now the function on the graph (for Orthofinder orthogroup input only).

```{r clique_og, cache=TRUE}
g <- igraph::graph_from_adjacency_matrix(bin_mat_clique_og, mode = "undirected", 
    weighted = NULL, diag = FALSE)
cliques_greedy <- greedy_clique(g, n_rep = 100)

## write the result to membership_community
membership_community$component_og <- "unknown"
membership_community$clique_og <- "unknown"

for (component_i in seq_along(cliques_greedy)) {
    
    component_name <- paste("component", component_i, sep = "_")
    for (clique_i in seq_along(cliques_greedy[[component_i]])) {
        clique_name <- paste(component_name, "clique", clique_i, sep = "_")
        
        ## find the rows of the members of the clique and write to 
        ## membership_community
        ind_rows <- which(
            membership_community$X %in% 
                cliques_greedy[[component_i]][[clique_i]])
        membership_community[ind_rows, "component_og"] <- component_name
        membership_community[ind_rows, "clique_og"] <- clique_name
    }
}
```

## Export the membership_community file

Export the membership community object

```{r export_membership_community}
write.table(membership_community, file = "membership_community.csv", 
    sep = ",", dec = ".", quote = FALSE, row.names = FALSE)
```

Export also the network file derived from the adjacency matrix `bin_mat_cut`.

```{r export_net_cut}
write_graph(net_cut, file = "bin_mat_cut_graphml_manually_removed_edges.xml", 
    format = "graphml")
```

# Plot the network

## cluster_fast_greedy

```{r plot_fc, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "fc"])
        
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## cluster_walktrap

```{r plot_wc, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "wc"])
        
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## cluster_leading_eigen

```{r plot_le, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "le"])
        
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## cluster_label_prop

```{r plot_lp, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "lp"])
        
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## cluster_louvain

```{r plot_ml, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "ml"])
        
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## cluster_infomap

```{r plot_im, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "im"])
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## og

```{r plot_og, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "og"])
        .color <- lapply(strsplit(as.character(.color), split = "/"),
            function(.color_i) paste(unique(.color_i), collapse = "/")) |>
            unlist() |>
            as.factor()
        
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## mcl

```{r plot_mcl, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), "mcl"])
        .color <- lapply(strsplit(as.character(.color), split = "/"),
            function (.color_i) paste(unique(.color_i), collapse = "/")) |>
            unlist() |>
            as.factor()
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```

## component_og_mcl

```{r plot_component_og_mcl, cache=TRUE}
if (all(names(V(net_cut)) == membership_community$X)) {
    .components <- decompose(net_cut)
    
    for (i in seq_along(.components)) {
        ## define the color
        .color <- as.factor(membership_community[
            match(names(V(.components[[i]])), membership_community$X), 
                "component_og_mcl"])
        
        ## do the actual plotting
        plot(.components[[i]], vertex.label = NA, vertex.size = 3,
             vertex.color = .color, main = paste("Component", i))
    }
}
```
